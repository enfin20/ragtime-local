# ==========================================
# GROUPE : api
# ==========================================


# ------------------------------------------
# FICHIER : api\main.py
# ------------------------------------------
import logging
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from database.connection import engine
from database.models import Base
from fastapi.exceptions import RequestValidationError
from fastapi.requests import Request
from fastapi.responses import JSONResponse
import logging
logging.getLogger("httpx").setLevel(logging.WARNING)

# Import des routes
from api.routes import ingest, chat, search, auth

# Configuration Logs
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("api")

# Initialisation DB (Au d√©marrage)
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="RAGTime Local API",
    description="API pour Ingestion et Chat RAG avec LLM Local",
    version="1.0.0"
)

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    # Affiche le corps de la requ√™te re√ßue et l'erreur de validation
    body = await request.body()
    print(f"\n‚ùå ERREUR 422 - Validation Failed:")
    print(f"üì• Body re√ßu : {body.decode('utf-8')}")
    print(f"‚ö†Ô∏è D√©tail erreur : {exc.errors()}\n")
    return JSONResponse(status_code=422, content={"detail": exc.errors(), "body": body.decode('utf-8')})



@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    # On √©vite de lire le body si c'est un upload de fichier ou s'il est d√©j√† consomm√©
    body_content = "N/A (Stream consumed or File Upload)"
    
    try:
        # On tente de lire le body uniquement si le stream n'est pas consomm√©
        # (Technique basique : on try/except)
        body = await request.body()
        body_content = body.decode('utf-8')
    except Exception:
        pass # Si on ne peut pas lire le body, on ignore

    print(f"\n‚ùå ERREUR 422 - Validation Failed:")
    print(f"üì• URL : {request.url}")
    print(f"üì¶ Body : {body_content}")
    print(f"‚ö†Ô∏è D√©tail erreur : {exc.errors()}\n")
    
    return JSONResponse(
        status_code=422, 
        content={"detail": exc.errors(), "body": str(body_content)}
    )


# Configuration CORS (Pour autoriser le frontend)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Enregistrement des routes
app.include_router(auth.router, prefix="/ingest", tags=["Auth"])
app.include_router(ingest.router, prefix="/ingest", tags=["Ingestion"])
app.include_router(chat.router, prefix="/chat", tags=["Chat"])
app.include_router(search.router, prefix="/search", tags=["Debug Search"])

@app.get("/")
def root():
    return {"status": "ok", "message": "RAGTime API is running üöÄ"}

if __name__ == "__main__":
    import uvicorn
    # Lancement serveur : host 0.0.0.0 pour √™tre accessible sur le r√©seau local
    uvicorn.run(app, host="0.0.0.0", port=8000)


# ------------------------------------------
# FICHIER : api\routes\auth.py
# ------------------------------------------
# Fichier : api/routes/auth.py
import os
import jwt
import logging
from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, HTTPException
from repositories.user import user_repository
from schemas.user import LoginRequest, LoginSuccessResponse
from dotenv import load_dotenv
load_dotenv()

logger = logging.getLogger(__name__)
router = APIRouter()

# R√©cup√©ration de la cl√© secr√®te (Comme en Node)
JWT_SECRET = os.getenv("JWT_SECRET", "votre_secret_par_defaut_a_changer")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_HOURS = 8 # Comme le '8h' de Node

@router.post("/login", response_model=LoginSuccessResponse)
async def login(credentials: LoginRequest):
    """
    Authentifie l'utilisateur et retourne un token JWT valide 8h.
    """
    try:
        # 1. V√©rification DB via Repository
        result = user_repository.verify_credentials(
            employee=credentials.employee, 
            password=credentials.password
        )
        
        # 2. Gestion √©chec (401)
        if not result["isValid"]:
            # Message exact de Node.js
            raise HTTPException(status_code=401, detail="INVALID_IDENTIFIERS")

        # 3. Cr√©ation du Payload JWT
        # Node: { employeeId: employee, employee: employee }
        expire = datetime.now(timezone.utc) + timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS)
        payload = {
            "employeeId": credentials.employee,
            "employee": credentials.employee,
            "exp": expire
        }

        # 4. Signature du Token
        token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)

        # 5. R√©ponse Succ√®s (Structure exacte Node)
        logger.info(f"‚úÖ Connexion r√©ussie pour : {credentials.employee}")
        
        return {
            "status": "success",
            "message": "CONNEXION_SUCCESS",
            "token": token,
            "services": result["services"]
        }

    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"‚ùå Erreur Login: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal Server Error")

# ------------------------------------------
# FICHIER : api\routes\chat.py
# ------------------------------------------
from fastapi import APIRouter, HTTPException
from services.chat import chat_service
from schemas.api import ChatRequest, ChatResponse

router = APIRouter()

@router.post("/", response_model=ChatResponse)
async def chat_endpoint(request: ChatRequest):
    try:
        result = chat_service.chat(
            question=request.question,
            employee=request.employee,
            tags=request.tags
        )
        return {
            "answer": result["response"],
            "sources": result["sources"]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ------------------------------------------
# FICHIER : api\routes\ingest.py
# ------------------------------------------
import shutil
import os
import uuid
import logging
from fastapi import APIRouter, UploadFile, File, Form, BackgroundTasks, Query
from typing import Optional
from services.files import files_service

from utils.linkedin_cleaner import clean_linkedin_url
from services.ingestion import ingestion_service
from repositories.doc import doc_repository
from repositories.credits import credits_repository
from repositories.prompt import prompt_repository
from schemas.api import IngestTextRequest, IngestUrlRequest, IngestResponse
from schemas.chat import ChatRequestNode # Le bon sch√©ma
from services.chat import chat_service     

logger = logging.getLogger(__name__)

router = APIRouter()

# ... [Garder les routes GET tags, prompts, etc. qui fonctionnaient] ...
# (Je ne les remets pas pour ne pas saturer la r√©ponse, elles sont correctes dans votre version pr√©c√©dente)

@router.get("/tags")
async def get_tags_legacy(employee: str = Query(...), job_id: Optional[str] = Query(None)):
    tags_data = doc_repository.get_tags_with_count(employee)
    credit_info = credits_repository.get_current_credit(employee)
    return {"status": "success", "tags": tags_data, "currentUsage": credit_info["currentUsage"], "totalCredit": credit_info["totalCredit"], "job_id": job_id or f"job_{uuid.uuid4()}"}

@router.get("/prompts")
async def get_prompts_legacy(employee: str = Query(...)):
    prompts_list = prompt_repository.get_prompts_for_user(employee)
    return {"status": "success", "prompts": prompts_list}

@router.get("/docscategories")
async def get_docs_categories_legacy(employee: str = Query("system"), job_id: Optional[str] = Query(None)):
    categories_data = doc_repository.get_all_active_categories()
    credit_info = credits_repository.get_current_credit(employee)
    return {"status": "success", "docscategories": categories_data, "currentUsage": credit_info["currentUsage"], "totalCredit": credit_info["totalCredit"], "job_id": job_id or f"job_{uuid.uuid4()}"}

@router.get("/urls")
async def ingest_url_get_legacy(url: str = Query(...), employee: str = Query(...)):
    cleaned_url = clean_linkedin_url(url) if "linkedin.com" in url else url
    doc = doc_repository.get_doc(doc_id=cleaned_url, employee=employee)
    return {"status": "success", "message": "doc retrieved", "data": [doc] if doc else []}

@router.delete("/urls")
async def ingest_url_delete_legacy(url: str = Query(...), employee: str = Query(...)):
    cleaned_url = clean_linkedin_url(url) if "linkedin.com" in url else url
    return doc_repository.delete_doc(doc_id=cleaned_url, employee=employee)

@router.post("/urls", response_model=IngestResponse)
async def ingest_url_post_legacy(request: IngestUrlRequest, fields: Optional[str] = Query(None)):
    return ingestion_service.process_input(input_data=request.url, employee=request.employee, tags=request.tags, origin=f"legacy_post_{fields}" if fields else "legacy_post")

@router.post("/text", response_model=IngestResponse)
async def ingest_text(request: IngestTextRequest):
    return ingestion_service.process_input(input_data=request.text, employee=request.employee, tags=request.tags, origin="api_text")

@router.post("/url", response_model=IngestResponse)
async def ingest_url(request: IngestUrlRequest):
    return ingestion_service.process_input(input_data=request.url, employee=request.employee, tags=request.tags, origin="api_url")

@router.post("/file", response_model=IngestResponse)
async def ingest_file(file: UploadFile = File(...), employee: str = Form("api_user"), tags: str = Form("")):
    temp_file_path = f"temp_{file.filename}"
    try:
        with open(temp_file_path, "wb") as buffer: shutil.copyfileobj(file.file, buffer)
        tag_list = [t.strip() for t in tags.split(",") if t.strip()]
        return ingestion_service.process_input(input_data=temp_file_path, employee=employee, tags=tag_list, origin="api_file")
    finally:
        if os.path.exists(temp_file_path): os.remove(temp_file_path)

@router.get("/version")
async def get_version(): return {"version": "locale"}

@router.get("/tags/{tag}/docs")
async def get_tags_docs_legacy(tag: str, employee: str = Query(...), job_id: Optional[str] = Query(None)):
    docs_list = doc_repository.get_docs_by_tag(employee, tag)
    credit_info = credits_repository.get_current_credit(employee)
    return {"status": "success", "docs": docs_list, "currentUsage": credit_info["currentUsage"], "totalCredit": credit_info["totalCredit"], "job_id": job_id or f"job_{uuid.uuid4()}"}

# =====================================================================
# ROUTE /userchat CORRIG√âE
# =====================================================================

@router.post("/chat")
async def chat_legacy(request: ChatRequestNode):
    return await user_chat_legacy(request)

@router.post("/userchat")
async def user_chat_legacy(request: ChatRequestNode):
    """
    Route compatible Node.js pour le chat.
    Utilise ChatRequestNode avec validateur 'tags' pour √©viter 422.
    """
    try:
        # Traitement
        chat_result = chat_service.handle_node_chat(request)
        
        # Info Cr√©dits
        credit_info = credits_repository.get_current_credit(request.employee)
        final_job_id = request.job_id if request.job_id else f"job_{uuid.uuid4()}"

        return {
            "status": "success",
            "response": chat_result["response"],
            "sources": chat_result["sources"],
            "currentUsage": credit_info["currentUsage"],
            "totalCredit": credit_info["totalCredit"],
            "job_id": final_job_id
        }
    except Exception as e:
        logger.error(f"‚ùå Erreur POST /ingest/userchat: {e}", exc_info=True)
        return {
            "status": "error",
            "response": f"Error: {str(e)}",
            "sources": []
        }
    
@router.post("/file", response_model=IngestResponse)
async def ingest_file(
    background_tasks: BackgroundTasks,
    # ---------------------------------------------------------
    # C'EST ICI LA CORRECTION : Le nom de variable DOIT √™tre docFile
    # pour matcher upload.single("docFile") du code Node.js
    # ---------------------------------------------------------
    docFile: UploadFile = File(...), 
    
    employee: str = Form(...),
    tags: str = Form(""),
    job_id: Optional[str] = Form(None)
):
    """
    Endpoint miroir de Node.js POST /file
    """
    logger.info(f"üì• [API] R√©ception fichier : {docFile.filename} | User: {employee}")

    # Nettoyage des tags comme dans Node (split sur virgule ou di√®se selon le besoin)
    # Node fait: tags.split("#").filter(Boolean)
    tag_list = [t.strip() for t in tags.replace("#", ",").split(",") if t.strip()]
    
    final_job_id = job_id or f"job_{uuid.uuid4()}"

    # Appel du service qui g√®re la logique m√©tier
    result = await files_service.handle_add_file_workflow(
        file=docFile,
        tags=tag_list,
        employee=employee,
        job_id=final_job_id,
        background_tasks=background_tasks
    )

    # R√©ponse imm√©diate au format Node.js
    return {
        "status": result["status"],
        "doc_id": docFile.filename,
        "chunks_count": 0, # Sera trait√© en background
        "strategy": "async_upload"
    }

# ------------------------------------------
# FICHIER : api\routes\search.py
# ------------------------------------------
from fastapi import APIRouter, HTTPException
from repositories.chunk import chunk_repository
from schemas.api import SearchRequest

router = APIRouter()

@router.post("/", summary="Recherche vectorielle brute (Debug)")
async def search_vector(request: SearchRequest):
    try:
        # On appelle le repository directement
        results = chunk_repository.search(
            query=request.query,
            employee=request.employee,
            limit=request.limit
        )
        
        # On reformate pour la lisibilit√©
        clean_results = []
        if results['ids']:
            for i, id_val in enumerate(results['ids'][0]):
                clean_results.append({
                    "id": id_val,
                    "score_distance": results['distances'][0][i] if 'distances' in results else "N/A",
                    "content": results['documents'][0][i], # <--- C'est √ßa qu'on veut v√©rifier !
                    "metadata": results['metadatas'][0][i]
                })
        
        return {"count": len(clean_results), "results": clean_results}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
